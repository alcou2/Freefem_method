/***********************************************************************
 *
 *  mexspbalance.c
 *  ==============
 *
 *  Sparse matrix balancing for Matlab.
 *
 *
 *  License
 *  -------
 *
 *  Copyright Ian Zwaan <i.n.zwaan@tue.nl> 2013 - 2016.  Distributed
 *  under the Boost Software License, Version 1.0; see below or copy at
 *  <http://www.boost.org/LICENSE_1_0.txt>.
 *  
 *  >   Boost Software License - Version 1.0 - August 17th, 2003
 *  >
 *  >   Permission is hereby granted, free of charge, to any person or
 *  >   organization obtaining a copy of the software and accompanying
 *  >   documentation covered by this license (the "Software") to use,
 *  >   reproduce, display, distribute, execute, and transmit the
 *  >   Software, and to prepare derivative works of the Software, and
 *  >   to permit third-parties to whom the Software is furnished to do
 *  >   so, all subject to the following:
 *  >
 *  >   The copyright notices in the Software and this entire statement,
 *  >   including the above license grant, this restriction and the
 *  >   following disclaimer, must be included in all copies of the
 *  >   Software, in whole or in part, and all derivative works of the
 *  >   Software, unless such copies or derivative works are solely in
 *  >   the form of machine-executable object code generated by a source
 *  >   language processor.
 *  >
 *  >   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  >   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 *  >   OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 *  >   NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
 *  >   ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR
 *  >   OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING
 *  >   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *  >   OTHER DEALINGS IN THE SOFTWARE.
 *
 *
 *  Description
 *  -----------
 *
 *  This MEX-file implements a sparse matrix balancing algorithm
 *  described by Tzu-Yi Chen and James W. Demmel.  The code is written
 *  entirely in C89 and consists of four major parts.
 *
 *  -   Special purpose sorting functions to improve upon the
 *      performance of the standard `qsort` and to return the
 *      permutation of the elements in the input array.
 *
 *  -   An implementation of Tarjan's algorithm for finding the strongly
 *      connected components of a directed graph whose adjacency matrix
 *      has the same structure as the input matrix. The strongly
 *      connected components are used to find a permutation of the input
 *      matrix which is "as block upper triangular as possible."
 *
 *  -   Balancing of the permuted matrix using the Parlett-Reinsch
 *      algorithm, implemented for sparse matrices. Special care is
 *      taken to avoid numerical overflow and underflow.
 *
 *  -   Finally, `mexFunction`, the interface between Matlab and the
 *      other parts of the code.
 *
 *  The balancing part is, with their permission, based on code provided
 *  by Chen and Demmel.
 *
 *  This work is part of the research programme "Innovative methods for
 *  large matrix problems", which is (partly) financed by the
 *  Netherlands Organisation for Scientific Research (NWO).
 *
 *
 *  References
 *  ----------
 *
 *  -   Chen, Tzu-Yi and Demmel, James W. "Balancing sparse matrices for
 *      computing eigenvalues." Linear algebra and its applications 309
 *      (2000): 261-287. Print.
 *
 *  -   Cormen, Thomas H. and Leiserson, Charles E. and Rivest, Ronald
 *      L.  and Stein, Clifford. "An introduction to algorithms," 2nd
 *      edition.  The MIT Press, 2001. Print.
 *
 *  -   "Tarjan's strongly connected components algorithm." Wikipedia:
 *      The Free Encyclopedia. Wikimedia Foundation, Inc. 6 October
 *      2013.  Web. 10 October 2013.
 *
 **********************************************************************/

#include <float.h>  /* For DBL_MIN and DBL_EPSILON. */
#include <math.h>   /* For fabs. */

#include "matrix.h"

/* The following three defines customize `spbalance`'s behavior. */
#define BAL_COMPLEX     1
#define BAL_FACTOR      2.0
#define BAL_THRESHOLD   0.95

/* For small arrays it is more efficient to simply use insertion sort
 * instead of, e.g., quicksort. The threshold can be set below. */
#define SORT_THRESHOLD  32

/* "Safe" minimum and maximum double precision floating point values
 * (assume conformance with the IEEE Standard for Floating-Point
 * Arithmetic). */
#define BAL_MIN     (DBL_MIN / DBL_EPSILON)
#define BAL_MAX     (1.0 / BAL_MIN)
#define BAL_MIN_FAC (BAL_MIN * BAL_FACTOR)
#define BAL_MAX_FAC (BAL_MAX / BAL_FACTOR)

/* NOTE: Matlab documentation explicitly states that "When using the mex
 * `-largeArrayDims` switch, `mwIndex` is equivalent to `size_t` in C".
 * Compiling in 32-bit compatibility mode is not supported. */
#ifdef MX_COMPAT_32
#   error compile with -largeArrayDims
#elif (mwIndex) -1 == 0xFFFFFFFFUL
#   define BAL_MSB 0x80000000UL
#elif (mwIndex) -1 == 0xFFFFFFFFFFFFFFFFUL
#   define BAL_MSB 0x8000000000000000UL
#else
#   error BAL_MSB not defined
#endif

/* Convenience macros. */
#define MIN(a, b) ((a) <= (b) ? (a) : (b))
#define MAX(a, b) ((a) >= (b) ? (a) : (b))

struct spmat {
    mwSize m;
    mwSize n;
    mwSize nnz;

    double *real;
    double *imag;

    /* Matlab uses compressed column storage. */
    mwIndex *rowidx;
    mwIndex *colptr;

    /* The most significant bit of `rowptr[k]` indicates wheter or not
     * entry `k` should contribute to the row and column sums during
     * balancing. Observe that the MSB of the `mwIndex` type is never
     * used for indices (in 32-bit compatibility mode `mwIndex` is
     * equivalent to `int` and the highest bit is the sign bit; with
     * `-largeArrayDims`, the amount of memory used would exceed the
     * amount of memory that can be indexed before the MSB is used).
     *
     * All other bits are used to build singly linked lists of row
     * entries, which can be used for fast row traversal. Specifically,
     * `k = rowbeg[i]` is the first entry in row `i` and the lower bits
     * of `k = rowbeg[k]` are the next one and so forth.  The end of the
     * list is reached when the lower bits of `k` equal `nnz`. */
    mwIndex *rowptr;
    mwIndex *rowbeg;
};

static void
sort_insert(mwIndex *a, mwSize n)
{
    mwIndex i, j, v;
    for (i = 1; i < n; ++i) {
        v = a[i];
        for (j = i; j && v < a[j-1]; --j) {
            a[j] = a[j-1];
        }
        a[j] = v;
    }
}

static void
sort_insert_p(mwIndex *a, mwSize n, mwIndex *p)
{
    mwIndex i, j, v, w;
    for (i = 1; i < n; ++i) {
        v = a[i];
        w = p[i];
        for (j = i; j && v < a[j-1]; --j) {
            a[j] = a[j-1];
            p[j] = p[j-1];
        }
        a[j] = v;
        p[j] = w;
    }
}

static mwIndex
sort_partition(mwIndex *a, mwIndex l, mwIndex h)
{
    mwIndex tmp, piv = a[(l+(--h))/2];
    while (l < h) {
        while (a[l] < piv && l < h) ++l;
        while (a[h] > piv && l < h) --h;
        tmp = a[l]; a[l] = a[h]; a[h] = tmp;
    }
    return l;
}

static mwIndex
sort_partition_p(mwIndex *a, mwIndex l, mwIndex h, mwIndex *p)
{
    mwIndex tmp, piv = a[(l+(--h))/2];
    while (l < h) {
        while (a[l] < piv && l < h) ++l;
        while (a[h] > piv && l < h) --h;
        tmp = a[l]; a[l] = a[h]; a[h] = tmp;
        tmp = p[l]; p[l] = p[h]; p[h] = tmp;
    }
    return l;
}

static void
sort_quick(mwIndex *a, mwIndex l, mwIndex h)
{
    if (h - l <= SORT_THRESHOLD) {
        sort_insert(a + l, h - l);
    } else {
        mwIndex m = sort_partition(a, l, h);
        sort_quick(a, l, m);
        sort_quick(a, m + 1, h);
    }
}

static void
sort_quick_p(mwIndex *a, mwIndex l, mwIndex h, mwIndex *p)
{
    if (h - l <= SORT_THRESHOLD) {
        sort_insert_p(a + l, h - l, p + l);
    } else {
        mwIndex m = sort_partition_p(a, l, h, p);
        sort_quick_p(a, l, m, p);
        sort_quick_p(a, m + 1, h, p);
    }
}

static void
sort(mwIndex *a, mwSize n)
{
    sort_quick(a, 0, n);
}

static void
sort_p(mwIndex *a, mwSize n, mwIndex *p)
{
    mwIndex i;
    for (i = 0; i < n; ++i) {
        p[i] = i;
    }
    sort_quick_p(a, 0, n, p);
}

static void
scc_tarjan(const struct spmat *mat, mwIndex *perm,
    mwIndex *sccidx, mwSize *nscc)
{
    mwIndex pi, k, kmax;
    mwIndex v, w, vl, wl;
    mwIndex top, *stack;
    mwIndex inc, *low, *num;
    mwIndex len, *pathv, *pathk;

    inc = k = len = *nscc = pi = top = 0;

    stack = mxMalloc(MIN(mat->n, mat->nnz) * sizeof(*stack));
    pathv = mxMalloc(MIN(mat->n, mat->nnz) * sizeof(*pathv));
    pathk = mxMalloc(MIN(mat->n, mat->nnz) * sizeof(*pathk));
    low = mxMalloc(mat->n * sizeof(*low));
    num = mxMalloc(mat->n * sizeof(*num));

    /* Initialize vertices to a pristine state. */
    for (v = 0; v < mat->n; ++v) {
        num[v] = ~BAL_MSB;
    }

    /* Connect each unconnected component. */
    for (v = 0; v < mat->n; ++v) {
        if (num[v] != ~BAL_MSB) {
            continue;
        }

scc_connect :
        if (num[v] == ~BAL_MSB) {
        k = mat->colptr[v];
            num[v] = BAL_MSB | inc;
            low[v] = BAL_MSB | inc++;
            stack[top++] = v;
        }

        kmax = mat->colptr[v+1];
        while (k != kmax) {
            w = mat->rowidx[k++];
            wl = num[w];
            if (wl == ~BAL_MSB) {
                /* w is not yet explored, recurse. */
                pathv[len] = v;
                pathk[len++] = k;
                v = w;
                /* Emulate recursion. */
                goto scc_connect;
            } else if (wl & BAL_MSB) {
                /* w is on the stack and hence in the current SCC. */
                vl = low[v];
                low[v] = MIN(vl, wl);
            }
        }

        /* Pop the stack and generate an SCC if v is a root vertex. */
        if (low[v] == num[v]) {
            sccidx[(*nscc)++] = pi;
            do {
                w = stack[--top];
                perm[pi++] = w;
                num[w] = 0;
            } while (w != v);
            sccidx[*nscc] = pi;
        }

        /* Emulate return of recursive function call. */
        if (len > 0) {
            w = v;
            v = pathv[--len];
            k = pathk[len];
            vl = low[v];
            wl = low[w];
            low[v] = MIN(vl, wl);
            goto scc_connect;
        }
    }

    mxFree(stack);
    mxFree(pathv);
    mxFree(pathk);
    mxFree(num);
    mxFree(low);
}

static void
spbalance(const struct spmat *mat, double *scale,
        const mwIndex *sccidx, mwSize nscc)
{
    int converged;
    mwIndex v, k, kmax;
    mwIndex scc, sccbegin, sccend;
    double z, rsum, csum, rmax, cmax, oldsum;
    double f, g;

    /* For every component/block. */
    for (scc = 0; scc < nscc; ++scc) {
        sccbegin = sccidx[scc];
        sccend = sccidx[scc+1];

        /* Components/blocks of size 1 do not need balancing. */
        if (1 == sccend - sccbegin) {
            continue;
        }

        converged = 0;
        while (!converged) {
            converged = 1;
            for (v = sccbegin; v < sccend; ++v) {
                /* Compute column sum and find maximum. */
                csum = 0.0;
                cmax = 0.0;
                kmax = mat->colptr[v+1];
                for (k = mat->colptr[v]; k != kmax; ++k) {
                    z = fabs(mat->real[k]);
#if BAL_COMPLEX
                    if (mat->imag) {
                        z += fabs(mat->imag[k]);
                    }
#endif
                    if (mat->rowptr[k] & BAL_MSB) {
                        csum += z;
                    }
                    cmax = MAX(cmax, z);
                }

                if (0.0 == csum) {
                    continue;
                }

                /* Compute row sum and find maximum. */
                rsum = 0.0;
                rmax = 0.0;
                kmax = mat->nnz;
                for (k = mat->rowbeg[v]; k != kmax; /**/) {
                    z = fabs(mat->real[k]);
#if BAL_COMPLEX
                    if (mat->imag) {
                        z += fabs(mat->imag[k]);
                    }
#endif
                    k = mat->rowptr[k];
                    if (k & BAL_MSB) {
                        rsum += z;
                        k &= ~BAL_MSB;
                    }
                    rmax = MAX(rmax, z);
                }

                if (0.0 == rsum) {
                    continue;
                }

                /* Reset scale factor f. */
                f = 1.0;
                oldsum = csum + rsum;

                /* Increase f if column sum < row sum. */
                g = rsum / BAL_FACTOR;
                while (csum < g
                        && f < BAL_MAX_FAC && g > BAL_MIN_FAC
                        && csum < BAL_MAX_FAC && cmax < BAL_MAX_FAC
                        && rsum > BAL_MIN_FAC && rmax > BAL_MIN_FAC) {
                    f *= BAL_FACTOR;
                    g /= BAL_FACTOR;
                    csum *= BAL_FACTOR;
                    cmax *= BAL_FACTOR;
                    rsum /= BAL_FACTOR;
                    rmax /= BAL_FACTOR;
                }

                /* Decrease f if rowsum <= column sum. */
                g = csum / BAL_FACTOR;
                while (rsum <= g
                        && f > BAL_MIN_FAC && g > BAL_MIN_FAC
                        && rsum < BAL_MAX_FAC && rmax < BAL_MAX_FAC
                        && csum > BAL_MIN_FAC && cmax > BAL_MIN_FAC) {
                    f /= BAL_FACTOR;
                    g /= BAL_FACTOR;
                    csum /= BAL_FACTOR;
                    cmax /= BAL_FACTOR;
                    rsum *= BAL_FACTOR;
                    rmax *= BAL_FACTOR;
                }

                /* Stop if there is insufficient improvement or if there
                 * is numerical overflow or underflow. */
                g = scale[v];
                if ((csum + rsum >= BAL_THRESHOLD * oldsum)
                        || (f < 1.0 && g < 1.0 && g <= BAL_MIN / f)
                        || (f > 1.0 && g > 1.0 && g >= BAL_MAX / f)) {
                    continue;
                }

                /* Update scale matrix. */
                scale[v] *= f;

                /* Scale column. */
                kmax = mat->colptr[v+1];
                for (k = mat->colptr[v]; k != kmax; ++k) {
                    mat->real[k] *= f;
#if BAL_COMPLEX
                    if (mat->imag) {
                        mat->imag[k] *= f;
                    }
#endif
                }

                /* Scale row. */
                g = 1.0 / f;
                kmax = mat->nnz;
                for (k = mat->rowbeg[v]; k != kmax;
                        k = mat->rowptr[k] & ~BAL_MSB) {
                    mat->real[k] *= g;
#if BAL_COMPLEX
                    if (mat->imag) {
                        mat->imag[k] *= g;
                    }
#endif
                }

                /* Not yet converged; repeat. */
                converged = 0;
            }
        }
    }
}

extern void
mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
    struct spmat mat, trans, bal;
    mwSize nscc;
    mwIndex i, j, k, l, kmax;
    mwIndex scc, sccbegin, sccend;
    mwIndex *sccidx, *perm;

    /* Check preconditions. */
    mxAssert(1 == nrhs, "expected one input argument");
    mxAssert(2 == nlhs, "expected two output arguments");
    mxAssert(mxIsDouble(prhs[0]), "expected input of class double");
    mxAssert(mxIsSparse(prhs[0]), "expected sparse input");
#if ~BAL_COMPLEX
    mxAssert(mxIsComplex(prhs[0]), "expected real input");
#endif

    /* NOTE: some of the memory allocated by the output matrices is
     * temporarily used for workspace. */

    mat.m = mxGetM(prhs[0]);
    mat.n = mxGetN(prhs[0]);
    mat.real = mxGetPr(prhs[0]);
    mat.imag = mxGetPi(prhs[0]);
    mat.rowidx = mxGetIr(prhs[0]);
    mat.colptr = mxGetJc(prhs[0]);
    mat.rowptr = NULL;
    mat.rowbeg = NULL;
    mat.nnz = (mwSize) mat.colptr[mat.n];

    /* Create transformation matrix. */
    plhs[0] = mxCreateSparse(mat.n, mat.n, mat.n, mxREAL);
    trans.m = mat.n;
    trans.n = mat.n;
    trans.nnz = mat.n;
    trans.real = mxGetPr(plhs[0]);
    trans.imag = NULL;
    trans.rowidx = mxGetIr(plhs[0]);
    trans.colptr = mxGetJc(plhs[0]);
    trans.rowptr = NULL;
    trans.rowbeg = NULL;

    /* Initialize scale. */
    for (k = 0; k < trans.n; ++k) {
        trans.real[k] = 1.0;
    }

    /* Return quickly if the input matrix is empty. */
    if (0 == mat.nnz) {
        plhs[1] = mxDuplicateArray(prhs[0]);
        for (k = 0; k < trans.n; ++k) {
            trans.rowidx[k] = k;
            trans.colptr[k] = k;
        }
        trans.colptr[trans.n] = trans.n;
        return;
    }

    /* Find Strongly Connected Components. */
    perm = trans.rowidx;
    sccidx = trans.colptr;
    scc_tarjan(&mat, perm, sccidx, &nscc);

    /* Sort vertices in each component. */
    if (1 == nscc) {
        for (k = 0; k < mat.n; ++k) {
            perm[k] = k;
        }
    } else {
        for (scc = 0; scc < nscc; scc++) {
            sort(perm + sccidx[scc], sccidx[scc+1] - sccidx[scc]);
        }
    }

    /* Create (not yet) balanced matrix. */
    if (1 == nscc) {
        plhs[1] = mxDuplicateArray(prhs[0]);
    } else {
        plhs[1] = mxCreateSparse(mat.m, mat.n, mat.nnz,
                mxIsComplex(prhs[0]) ? mxCOMPLEX : mxREAL);
    }

    bal.m = mat.m;
    bal.n = mat.n;
    bal.nnz = mat.nnz;
    bal.real = mxGetPr(plhs[1]);
    bal.imag = mxGetPi(plhs[1]);
    bal.rowidx = mxGetIr(plhs[1]);
    bal.colptr = mxGetJc(plhs[1]);
    bal.rowptr = mxMalloc(bal.nnz * sizeof(*bal.rowptr));
    bal.rowbeg = mxMalloc((bal.m + 1) * sizeof(*bal.rowbeg));

    /* Permute matrix if necessary. */
    if (1 != nscc) {
        mwIndex kmin, lmin;
        mwIndex *orig, *swap;

        /* `nnz` could be less than `n`, but there cannot be more rows
         * than non-zeros (hence, `orig = bal.rowptr` is fine)! */
        orig = bal.rowptr;
        swap = bal.rowbeg;

        /* Compute the inverse permutation. */
        for (k = 0; k < mat.n; ++k) {
            swap[perm[k]] = k;
        }

        /* Create permuted matrix. */
        l = 0;
        for (j = 0; j < mat.n; ++j) {
            bal.colptr[j] = l;

            lmin = l;
            kmin = mat.colptr[perm[j]];
            kmax = mat.colptr[perm[j]+1];

            /* Copy row indices. */
            for (k = kmin; k != kmax; ++k) {
                bal.rowidx[l++] = swap[mat.rowidx[k]];
            }

            /* Sort row indices; sorting is necessary for Matlab. */
            sort_p(bal.rowidx + lmin, kmax - kmin, orig);

            /* Copy numeric data. */
            for (k = 0; k < kmax - kmin; ++k) {
                bal.real[lmin+k] = mat.real[kmin+orig[k]];
#if BAL_COMPLEX
                if (bal.imag) {
                    bal.imag[lmin+k] = mat.imag[kmin+orig[k]];
                }
#endif
            }
        }
        bal.colptr[bal.n] = bal.nnz;
    }

    /* Initialize chains for fast row traversal. */
    for (i = 0; i < bal.m; ++i) {
        bal.rowbeg[i] = bal.nnz;
    }
    bal.rowbeg[bal.m] = bal.nnz;

    /* Create chains for fast row traversal. */
    for (scc = 0; scc < nscc; ++scc) {
        sccbegin = sccidx[scc];
        sccend = sccidx[scc+1];
        for (j = sccbegin; j != sccend; ++j) {
            kmax = bal.colptr[j+1];
            for (k = bal.colptr[j]; k != kmax; ++k) {
                i = bal.rowidx[k];

                /* Set the most significant bit if an entry is not on
                 * the diagonal but within a block (so it contributes to
                 * the row and column sums during balancing). */
                l = bal.rowbeg[i];
                if (i != j && sccbegin <= i && i < sccend) {
                    l |= BAL_MSB;
                }

                bal.rowptr[k] = l;
                bal.rowbeg[i] = k;
            }
        }
    }

    /* Balance matrix. */
    spbalance(&bal, trans.real, sccidx, nscc);

    /* The `colptr` (jc) array of the transformation matrix was used as
     * workspace (`sccidx`). The array must be (re)set. */
    for (j = 0; j < trans.n; ++j) {
        trans.colptr[j] = j;
    }
    trans.colptr[trans.n] = trans.n;

    mxFree(bal.rowptr);
    mxFree(bal.rowbeg);
}
